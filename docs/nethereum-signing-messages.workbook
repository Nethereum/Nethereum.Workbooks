---
uti: com.xamarin.workbook
id: e5cc8ec1-5a9d-4ff2-b229-a7c1d489a8ca
title: nethereum-signing-messages
platforms:
- Console
packages:
- id: Nethereum.Web3
  version: 3.0.0
---

# Signing messages with Nethereum

This document is a Workbook, find more about workbooks installation requirements  [here](https://docs.microsoft.com/en-us/xamarin/tools/workbooks/install).

Nethereum provides methods to sign messages in an Ethereum compatible format. The following is a quick guide to signing a string with Nethereum and verifying a signature using various methods.

## Ethereum signing basics

In the Ethereum context, signing a message allows us to certify that a piece of data was signed by a specific account, it's a way to prove to a smart contract/human that an account approved a message.

Signing a message with a private key does not require interacting with the Ethereum network. It can be done completely offline, hence the following code can be run without a testchain running.

Nethereum provides an object that can be used to sign or verify messages: `EthereumMessageSigner`. 
Let's now explore how to use `EthereumMessageSigner` with the two most common scenarios in the Ethereum context.

## Signing messages and verifying signatures with Nethereum

```csharp
#r "Nethereum.Web3"
```

```csharp
#r "Nethereum.ABI"
```

```csharp
using Nethereum.Web3;
using Nethereum.Util;
using System.Collections.Generic;
using System.Text;
using Nethereum.Signer;
using Nethereum.Hex.HexConvertors.Extensions;
using Nethereum.ABI.Encoders;
```

**address** declares the signer's account address:

```csharp
var address = "0x12890d2cce102216644c59dae5baed380d84830c";
```

**msg1** declares the content of the message itself, here is a simple string:

```csharp
var msg1 = "wee test message 18/09/2017 02:55PM";
```

**privatekey** declares the private key of the signerâ€™s **account**:

```csharp
var privateKey = "0xb5b1870957d373ef0eeffecc6e4812c0fd08f554b37b233526acc331bf1544f7";
```

**signer1** creates an instance of the **EthereumMessageSigner** object:

```csharp
var signer1 = new EthereumMessageSigner();
```

### 1-Encoding and signing a message using EncodeUTF8AndSign:

The most common scenario when signing a message goes as follows:

A message needs to be signed, it's most likely a string and hence can be encoded in UTF8 and then signed, therefore we will use `EncodeUTF8AndSign`

`EncodeUTF8AndSign` requires two arguments:
- The message itself
- The signing account's private key

```csharp
var signature1 = signer1.EncodeUTF8AndSign(msg1, new EthECKey(privateKey));
```

### 2-Encoding and recovering the address of the signer's UTF8 message and signature using EncodeUTF8AndEcRecover:

The Ethereum signature verification process is a bit different from classical digital signatures, here the output of a signature verification is not the message (or the message hash) but the signer's address, since the address is a part of the public key hash.
Verification is successful if the recovered address is equal to the provided address, which can only happen if the signer is the owner of the account's private key.



**addressRec1** evaluates to the signer's address, thus proving the validity of the message.

In this case the **EncodeUTF8AndEcRecover** method is used to verify the signer's address of a message encoded in UTF8:


```csharp
var addressRec1 = signer1.EncodeUTF8AndEcRecover(msg1, signature1);
```

### 3-Hashing and signing a message using **HashAndSign**:
 
In some cases, hashing a file and then signing it might be more relevant, i.e. when dealing with an extremely large file.

**HashAndSign** enables you to do this in one go:
```csharp
var msg2 = "test";
var signer2 = new EthereumMessageSigner();
var signature2 = signer2.HashAndSign(msg2,
                "0xb5b1870957d373ef0eeffecc6e4812c0fd08f554b37b233526acc331bf1544f7");
```

### 4-Verifying a hashed message using **HashAndEcRecover**:

When receiving a signature that has been made using a file's hash it's necessary to hash the file in order to verify its signature. 

**HashAndEcRecover** enables you to do this in one single step:
```csharp
var addressRec2 = signer2.HashAndEcRecover(msg2, signature2);
```
### 5-Verifying a signature that has a signature prefix

Most Ethereum clients will automatically add a prefix to the message they sign. That method ([eth\_sign](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign)) is enforced to enable the receiver of a signed message to know what they are signing.

The hashed prefix of an ethereum signed message always contains the same elements: 
- 0x19
- the prefix enforced by Ethereum clients ("Ethereum Signed Message:\\n" + hash.HexToByteArray().Length));

- the hashed version of the original message (hashing messages ensures the 'message' part of the prefix has always the same length )
Nethereum allows to verify messages with a prefix in a signed message using `EthereumMessageSigner` which inherits from `MessageSigner`. 

In this example, we will use a signature made using geth 1.5 and that therefore includes a prefix: 

```csharp
var signature = "0x0976a177078198a261faf206287b8bb93ebb233347ab09a57c8691733f5772f67f398084b30fc6379ffee2cc72d510fd0f8a7ac2ee0162b95dc5d61146b40ffa1c";
```

The method we will use requires two arguments: the signature we want to verify and the hash prefix of the signed message in Byte Array format. 

we already have the signature, let's now determine the hashed prefix of the signature in byte array format.

We can start by hashing our message:
```csharp
            var text = "test";
            var hasher = new Sha3Keccack();
            var hash = hasher.CalculateHash(text);
```
We then need to obtain a Byte Array version of each prefixes in the signature and build a list with them: 
```csharp
            var byteList = new List<byte>();

            var bytePrefix = "0x19".HexToByteArray();
            var textBytePrefix = Encoding.UTF8.GetBytes("Ethereum Signed Message:\n" + hash.HexToByteArray().Length);
            var bytesMessage = hash.HexToByteArray();

            byteList.AddRange(bytePrefix);
            byteList.AddRange(textBytePrefix);
            byteList.AddRange(bytesMessage);
```

`hashPrefix2` represents the Hex version of the byte prefix: 
```csharp
            var hashPrefix2 = hasher.CalculateHash(byteList.ToArray()).ToHex();
```

Finally, we will convert `hashPrefix2` to a Byte Array and use `EcRecover` to verify the signature:

```csharp
            var signer = new MessageSigner();
            var account = signer.EcRecover(hashPrefix2.HexToByteArray(), signature);
```

