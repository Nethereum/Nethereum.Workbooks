---
uti: com.xamarin.workbook
id: e5cc8ec1-5a9d-4ff2-b229-a7c1d489a8ca
title: nethereum-signing-messages
platforms:
- Console
packages:
- id: Nethereum.Web3
  version: 3.0.0
---

# Signing messages with Nethereum

This document is a Workbook, find more about workbooks installation requirements  [here](https://docs.microsoft.com/en-us/xamarin/tools/workbooks/install).

Nethereum provides methods to sign messages in an Ethereum compatible format. The following is a quick guide to signing a string with Nethereum and verifying a signature using various methods.

## Ethereum signing basics

In the Ethereum context, signing a message allows us to certify that a piece of data was signed by a specific account, it's a way to prove to a smart contract/human that an account approved a message.

Signing a message with a private key does not require interacting with the Ethereum network. It can be done completely offline, hence the following code can be run without a testchain running.

Nethereum provides two objects that can be used to sign or verify messages: `EthereumMessageSigner` that allows you to sign and verify in various formats, and `EthereumSigner` which enables the management of prefixes (more about prefixes later in this article).

## Signing messages and verifying signatures with Nethereum

```csharp
#r "Nethereum.Web3"
```

```csharp
#r "Nethereum.ABI"
```

```csharp
using Nethereum.Web3;
using Nethereum.Util;
using System.Collections.Generic;
using System.Text;
using Nethereum.Signer;
using Nethereum.Hex.HexConvertors.Extensions;
using Nethereum.ABI.Encoders;
```

**address** declares the signer's account address:

```csharp
var address = "0x12890d2cce102216644c59dae5baed380d84830c";
```

**msg1** declares the content of the message itself, here is a simple string:

```csharp
var msg1 = "wee test message 18/09/2017 02:55PM";
```

**privatekey** declares the private key of the signer’s **account**:

```csharp
var privateKey = "0xb5b1870957d373ef0eeffecc6e4812c0fd08f554b37b233526acc331bf1544f7";
```

**signer1** creates an instance of the **EthereumMessageSigner** object:

```csharp
var signer1 = new EthereumMessageSigner();
```

### 1-Encoding and signing a message using EncodeUTF8AndSign:

* **EncodeUTF8AndSign** will encode the UTF8 signer's message (`msg1`) with their private key (`privateKey`) and return a string representing the signature.

```csharp
var signature1 = signer1.EncodeUTF8AndSign(msg1, new EthECKey(privateKey));
```

**Note about signature verification in Ethereum:**

Ethereum signature process is a bit different from classical digital signatures, here the output of a signature verification is not the message (or the message hash) but the signer's address, since the address is a part of the public key hash.
Verification is successful if the recovered address is equal to the provided address, which can only happen if the signer is the owner of the account's private key.

### 2-Encoding and recovering the address of the signer's UTF8 message and signature using EncodeUTF8AndEcRecover:

**addressRec1** evaluates to the signer's address, thus proving the validity of the message.

In this case the **EncodeUTF8AndEcRecover** method is used to verify the signer's address of a message encoded in UTF8:

```csharp
var addressRec1 = signer1.EncodeUTF8AndEcRecover(msg1, signature1);
```

### 3-Hashing and signing a message using **HashAndSign**:

```csharp
var msg2 = "test";
var signer2 = new EthereumMessageSigner();
var signature2 = signer2.HashAndSign(msg2,
                "0xb5b1870957d373ef0eeffecc6e4812c0fd08f554b37b233526acc331bf1544f7");
```

### 4-Verifying a hashed message using **HashAndEcRecover**:

```csharp
var addressRec2 = signer2.HashAndEcRecover(msg2, signature2);
```

### 5-Verifying a signature that has a signature prefix

Most Ethereum clients will automatically add a prefix to the message they sign. That method ([eth\_sign](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign)) is enforced to enable the receiver of a signed message to know what they are signing.

Nethereum enables you to verify messages with a prefix in a signed message by using `MessageSigner`.

In this example, we will use a signature made using geth 1.5:

```csharp
var signature = "0x0976a177078198a261faf206287b8bb93ebb233347ab09a57c8691733f5772f67f398084b30fc6379ffee2cc72d510fd0f8a7ac2ee0162b95dc5d61146b40ffa1c";
```

The method that we will use requires two arguments: the signature to verify and a signed version of the message in Byte Array format. We’ll create the Byte Array signature using the text that was signed:

```csharp
            var text = "test";
            var hasher = new Sha3Keccack();
            var hash = hasher.CalculateHash(text);
            var byteList = new List<byte>();

            var bytePrefix = "0x19".HexToByteArray();
            var textBytePrefix = Encoding.UTF8.GetBytes("Ethereum Signed Message:\n" + hash.HexToByteArray().Length);
            var bytesMessage = hash.HexToByteArray();

            byteList.AddRange(bytePrefix);
            byteList.AddRange(textBytePrefix);
            byteList.AddRange(bytesMessage);
```

`hashPrefix2` represents the hashed version of the message with its byte prefix plus the prefix enforced by Ethereum clients ("Ethereum Signed Message:\\n" + hash.HexToByteArray().Length));

```csharp
            var hashPrefix2 = hasher.CalculateHash(byteList.ToArray()).ToHex();
```

Finally, we will convert `hashPrefix2` to a Byte Array and use `EcRecover` to verify the signature:

```csharp
            var signer = new MessageSigner();
            var account = signer.EcRecover(hashPrefix2.HexToByteArray(), signature);
```

* Please note: you can also verify the validity of your signature at the following link:
  <https://etherscan.io/verifySig>