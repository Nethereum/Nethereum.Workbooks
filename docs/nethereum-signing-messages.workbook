---
uti: com.xamarin.workbook
id: e5cc8ec1-5a9d-4ff2-b229-a7c1d489a8ca
title: nethereum-signing-messages
platforms:
- Console
packages:
- id: Nethereum.Web3
  version: 3.0.0
---

# Signing messages with Nethereum

This document is a Workbook, find more about workbooks installation requirements  [here](https://docs.microsoft.com/en-us/xamarin/tools/workbooks/install).

Nethereum provides with methods to sign messages in an Ethereum compatible format. The following is a quick guide to signing a string with Nethereum and verifying a signature using various methods.

## Ethereum signing basics

In the Ethereum context, signing a message allows to certify that a piece of data was signed by a specific account, it's a way to prove to a smart contract/human that an account approved a message.

Signing a message with a private key does not require interacting with the Ethereum network. It can be done completely offline, hence the following code can be run without a testchain running.

Nethereum provides with two objects that can be used to sign or verify messages: `EthereumMessageSigner` that allows to sign and verify in various formats, and `EthereumSigner` which enables the management of prefixes (more about prefixes later in this article).

## Signing messages and verifying signatures with Nethereum 

```csharp
#r "Nethereum.Web3"
```

```csharp
#r "Nethereum.ABI"
```

```csharp
using Nethereum.Web3;
using Nethereum.Util;
using System.Collections.Generic;
using System.Text;
using Nethereum.Signer;
using Nethereum.Hex.HexConvertors.Extensions;
using Nethereum.ABI.Encoders;
```

**address** declares the signer's account address:

```csharp
var address = "0x12890d2cce102216644c59dae5baed380d84830c";
```

**msg1** declares the content of the message itself, here a simple string:

```csharp
var msg1 = "wee test message 18/09/2017 02:55PM";
```

**privatekey** declares the private key of the sending **account**:

```csharp
var privateKey = "0xb5b1870957d373ef0eeffecc6e4812c0fd08f554b37b233526acc331bf1544f7";
```

**signer1** creates an instance of the **EthereumMessageSigner** object:

```csharp
var signer1 = new EthereumMessageSigner();
```

### 1-Encoding and signing a message using EncodeUTF8AndSign:

* **EncodeUTF8AndSign** will encode the UTF8 signer's message (`msg1`) with their private key (`privateKey`) and return a string representing the signature.

```csharp
var signature1 = signer1.EncodeUTF8AndSign(msg1, new EthECKey(privateKey));
```

**Note about signature verification in Ethereum:**

Ethereum signature process is a bit different from classical digital signatures, here the output of a signature verification is not the message (or the message hash) but the signer's address, since the address is a part of the public key hash.
Verification is successful if the recovered address is equal to the provided address, which can only happen if the signer is the owner of the account's private key.

### 2-Encoding and recovering the address of the signer's UTF8 message and signature using EncodeUTF8AndEcRecover:

**addressRec1** evaluates to the signer's address, thus proving the validity of the message.

In this case the **EncodeUTF8AndEcRecover** method is used to verify the signer's address of a message encoded in UTF8:

```csharp
var addressRec1 = signer1.EncodeUTF8AndEcRecover(msg1, signature1);
```

### 3-Verifying a signature that has a signature prefix

Most Ethereum clients will automatically add a prefix to the message they sign. That method ([eth\_sign](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign)) is enforced to enable the receiver of a signed message to know what they are signing.

Nethereum allows to verify messages with a prefix in a signed message using `MessageSigner`. 

In this example, we will use a signature made using geth 1.5 and that therefore includes a prefix: 

```csharp
var signature = "0x0976a177078198a261faf206287b8bb93ebb233347ab09a57c8691733f5772f67f398084b30fc6379ffee2cc72d510fd0f8a7ac2ee0162b95dc5d61146b40ffa1c";
```

The method we will use requires two arguments: the signature we want to verify and the hash prefix of the signed message in Byte Array format. 

We already have the signature, let's now determine the hashed prefix of the signature in Byte Array format.
The hased prefix of an Ethereum signed message always contains the same elements: 
- 0x19
- the prefix enforced by Ethereum clients ("Ethereum Signed Message:\\n" + hash.HexToByteArray().Length));
- the hashed version of the original message (hashing messages ensures the 'message' part of the prefix has always the same length )

We can start by hashing our message:
```csharp
            var text = "test";
            var hasher = new Sha3Keccack();
            var hash = hasher.CalculateHash(text);
```
We then need to obtain a Byte Array version of each prefixes in the signature and build a list with them: 
```csharp
            var byteList = new List<byte>();

            var bytePrefix = "0x19".HexToByteArray();
            var textBytePrefix = Encoding.UTF8.GetBytes("Ethereum Signed Message:\n" + hash.HexToByteArray().Length);
            var bytesMessage = hash.HexToByteArray();

            byteList.AddRange(bytePrefix);
            byteList.AddRange(textBytePrefix);
            byteList.AddRange(bytesMessage);
```

`hashPrefix2` represents the Hex version of the byte prefix: 
```csharp
            var hashPrefix2 = hasher.CalculateHash(byteList.ToArray()).ToHex();
```

Finally, we will convert `hashPrefix2` to a Byte Array and use `EcRecover` to verify the signature:

```csharp
            var signer = new MessageSigner();
            var account = signer.EcRecover(hashPrefix2.HexToByteArray(), signature);
```

* Please note: you can also verify the validity of your signature at the following link:
  <https://etherscan.io/verifySig>
