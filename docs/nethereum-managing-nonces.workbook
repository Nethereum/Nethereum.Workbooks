---
uti: com.xamarin.workbook
id: 7c6a7c28-9e2c-4536-8cb3-841b6173cacb
title: nethereum-managing-nonces
platforms:
- Console
packages:
- id: Nethereum.Web3
  version: 3.0.0
---

# Managing nonces with Nethereum

This document is a Workbook, find more about workbooks' installation requirements  [here](https://docs.microsoft.com/en-us/xamarin/tools/workbooks/install).

To prevent replay attacks (submitting the same transaction several times) Ethereum provides a transaction counter: the `nonce` parameter. Nonce keeps track of the number of times a transaction has been run by an account.

When making a transaction in Ethereum, a consecutive number should be attached to each transaction on the same account. Each node will process transactions from a specific account in a strict order according to the value of its nonce.

Therefore, failing to increment this value correctly can result in different kinds of errors. For instance, let’s say the latest transaction nonce was 121:

Reusing nonce: if we send a new transaction for the same account with a nonce of either 121 or below, the node will reject it.
“Gaps”: if we send a new transaction with a nonce of either 123 or higher, the transaction will not be processed until this gap is closed, i.e. until a transaction with nonce 122 has been processed.

## How Nethereum helps managing nonces
The nonce for the next transaction, can be simply defined as the total number of transactions for that account. The transaction count can be retrieved using "web3.Eth.GetTransactionCount.SendRequestAsync(account, BlockParameter.CreatePending())". This includes the total number of transactions including the pending transactions, which have been submitted but are yet to be included in the blockchain.

There is a small delay when transactions are included on the pending queue by clients like Geth or Parity. If we rely on the the transaction count, this can be an issue, if we are batching transactions at a faster rate that are included on the pending transaction queue.

To keep nonce count in sync between a Nethereum Dapp and the client it communicates with, Nethereum provides a `NonceService`, which can be assigned to the transaction manager, the default NonceService provides an in memory counter of the number of transactions / nonces.

## Prerequisites:

First, let's download the test chain matching your environment from <https://github.com/nethereum/testchains>

Start a geth chain (geth-clique-linux\\, geth-clique-windows\\ or geth-clique-mac\\) using **startgeth.bat** (windows) or **startgeth.sh** (mac/linux). the chain is setup with the proof of authority consensus and will start the mining process immediately.

```csharp
#r "nethereum.web3"
```

```csharp
#r "nethereum.Accounts"
```

after that, we will need to add `using` statements:

```csharp
using Nethereum.Web3;
using Nethereum.Web3.Accounts;
using Nethereum.Web3.Accounts.Managed;
using Nethereum.Signer;
using Nethereum.Hex.HexConvertors.Extensions;
using Nethereum.KeyStore;
using Nethereum.Hex.HexConvertors;
using Nethereum.Hex.HexTypes;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Threading.Tasks;
using Nethereum.RPC.NonceServices;
using Nethereum.RPC.TransactionReceipts;
```

## Nonce management with Nethereum `accounts` objects

In most cases, Nethereum takes care of incrementing the `nonce` automatically (unless you need to sign a raw transaction manually, we'll explain that in the next chapter).

Once you have loaded your private keys into your account, if Web3 is instantiated with that account all the transactions made using the TransactionManager, Contract deployment or Functions will be signed offline using the latest nonce.

Nonce management is insured whether you are using an `account` or a `managed account` object.

Example:
This example shows what happens to the `nonce` value when we send a transaction with a Nethereum account.
We first need to create an instance of an account, then use it to
instantiate a `web3` object.

* `web3` is the Web3 instance using the new `account` as constructor

```csharp
var privateKey = "0xb5b1870957d373ef0eeffecc6e4812c0fd08f554b37b233526acc331bf1544f7";
var account = new Nethereum.Web3.Accounts.Account(privateKey);
var web3 = new Web3(account);
```

Let's now examine what happens to the `nonce` value before and after we send a transaction:

#### Before a transaction is sent:

`txCount` represents the `nonce` object:

NOTE: THIS IS WRONG, THIS IS RETRIEVING THE NONCE FROM THE CLIENT USING THE TRANSACTION COUNT
```csharp
var txCount = await web3.Eth.Transactions.GetTransactionCount.SendRequestAsync(account.Address);
```

Now, let's send a simple transaction:

```csharp
var recipientAddress = "0xde0b295669a9fd93d5f28d9ec85e40f4cb697bae";
var transaction = await web3.TransactionManager.SendTransactionAsync(account.Address, recipientAddress, new HexBigInteger(1));
```

#### After a transaction has been sent

```csharp
var txCount2 = await web3.Eth.Transactions.GetTransactionCount.SendRequestAsync(account.Address);
var nonce2 = txCount2.Value;
```

As the above code demonstrates, the `nonce` was automatically incremented, thanks to the use of `TransactionManager`.

Nevertheless are scenarios where we might want to supply a Nonce manually, for example if we want to sign a transaction completely offline.

## Sending a transaction with an arbitrary nonce

The below shows how to verify the number of transactions performed from an account and

Let's first create an object instance of `TransactionSigner`

```csharp
var OfflineTransactionSigner = new TransactionSigner();
```
Before executing the below, make sure you restart your devchain by exiting the running instance and launching using `startgeth` (for geth client) or `launch` (for parity). 

First, let's check again what the current nonce is (if you duly restarted your chain, this should return `0`).
```csharp
var txValue = await web3.Eth.Transactions.GetTransactionCount.SendRequestAsync(account.Address);
var currentNonce = txValue.Value;
```
We can now decide to assign an arbitrary nonce (any bigger than the current nonce)
```csharp
var manualNonce = 12;
```

We can now sign our transaction offline:
```csharp
var encoded = OfflineTransactionSigner.SignTransaction(privateKey, recipientAddress, 10,
                manualNonce);
```
We can now send our transaction.
```csharp
var txId = await web3.Eth.Transactions.SendRawTransaction.SendRequestAsync("0x" + encoded);
```
